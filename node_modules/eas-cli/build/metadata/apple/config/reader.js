"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppleConfigReader = exports.DEFAULT_WHATSNEW = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const uniq_1 = tslib_1.__importDefault(require("../../../utils/expodash/uniq"));
const date_1 = require("../../utils/date");
// TODO: find out if we can move this to default JSON schema normalization
exports.DEFAULT_WHATSNEW = 'Bug fixes and improved stability';
/**
 * Deserializes the metadata config schema into attributes for different models.
 * This uses version 0 of the config schema.
 */
class AppleConfigReader {
    constructor(schema) {
        this.schema = schema;
    }
    getAgeRating() {
        return this.schema.advisory || null;
    }
    getLocales() {
        // TODO: filter "default" locales, add option to add non-localized info to the config
        return (0, uniq_1.default)(Object.keys(this.schema.info || {}));
    }
    getInfoLocale(locale) {
        var _a, _b;
        const info = (_a = this.schema.info) === null || _a === void 0 ? void 0 : _a[locale];
        if (!info) {
            return null;
        }
        return {
            locale,
            name: (_b = info.title) !== null && _b !== void 0 ? _b : 'no name provided',
            subtitle: info.subtitle,
            privacyChoicesUrl: info.privacyChoicesUrl,
            privacyPolicyText: info.privacyPolicyText,
            privacyPolicyUrl: info.privacyPolicyUrl,
        };
    }
    getCategories() {
        if (Array.isArray(this.schema.categories) && this.schema.categories.length > 0) {
            return {
                primaryCategory: this.schema.categories[0],
                secondaryCategory: this.schema.categories[1],
            };
        }
        return null;
    }
    /** Get the `AppStoreVersion` object. */
    getVersion() {
        return this.schema.copyright ? { copyright: this.schema.copyright } : null;
    }
    getVersionRelease() {
        var _a, _b;
        const { release } = this.schema;
        if (release === null || release === void 0 ? void 0 : release.autoReleaseDate) {
            return {
                releaseType: apple_utils_1.ReleaseType.SCHEDULED,
                // Convert time format to 2020-06-17T12:00:00-07:00
                earliestReleaseDate: (_b = (_a = (0, date_1.removeDatePrecision)(release.autoReleaseDate)) === null || _a === void 0 ? void 0 : _a.toISOString()) !== null && _b !== void 0 ? _b : null,
            };
        }
        if ((release === null || release === void 0 ? void 0 : release.automaticRelease) === true) {
            return {
                releaseType: apple_utils_1.ReleaseType.AFTER_APPROVAL,
                earliestReleaseDate: null,
            };
        }
        if ((release === null || release === void 0 ? void 0 : release.automaticRelease) === false) {
            return {
                releaseType: apple_utils_1.ReleaseType.MANUAL,
                earliestReleaseDate: null,
            };
        }
        return null;
    }
    getVersionLocale(locale, context) {
        var _a, _b;
        const info = (_a = this.schema.info) === null || _a === void 0 ? void 0 : _a[locale];
        if (!info) {
            return null;
        }
        return {
            locale,
            description: info.description,
            keywords: (_b = info.keywords) === null || _b === void 0 ? void 0 : _b.join(', '),
            // TODO: maybe move this to task logic, it's more an exception than data handling
            whatsNew: context.versionIsFirst ? undefined : info.releaseNotes || exports.DEFAULT_WHATSNEW,
            marketingUrl: info.marketingUrl,
            promotionalText: info.promoText,
            supportUrl: info.supportUrl,
        };
    }
}
exports.AppleConfigReader = AppleConfigReader;
