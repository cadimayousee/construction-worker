"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppVersionTask = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_1 = tslib_1.__importDefault(require("../../../log"));
const log_2 = require("../../utils/log");
const retry_1 = require("../../utils/retry");
const task_1 = require("../task");
class AppVersionTask extends task_1.AppleTask {
    constructor(options = {}) {
        var _a, _b;
        super();
        this.name = () => (this.options.editLive ? 'live app version' : 'editable app version');
        this.options = {
            platform: (_a = options.platform) !== null && _a !== void 0 ? _a : apple_utils_1.Platform.IOS,
            editLive: (_b = options.editLive) !== null && _b !== void 0 ? _b : false,
        };
    }
    async prepareAsync({ context }) {
        const { version, versionIsFirst, versionIsLive } = await resolveVersionAsync(context.app, this.options);
        (0, assert_1.default)(version, 'Could not resolve a live or editable app version');
        context.version = version;
        context.versionIsFirst = versionIsFirst;
        context.versionIsLive = versionIsLive;
        context.versionLocales = await version.getLocalizationsAsync();
    }
    async downloadAsync({ config, context }) {
        (0, assert_1.default)(context.version, `App version not initialized, can't download version`);
        config.setVersion(context.version.attributes);
        config.setVersionRelease(context.version.attributes);
        for (const locale of context.versionLocales) {
            config.setVersionLocale(locale.attributes);
        }
    }
    async uploadAsync({ config, context }) {
        (0, assert_1.default)(context.version, `App version not initialized, can't update version`);
        const version = config.getVersion();
        const release = config.getVersionRelease();
        if (!version && !release) {
            log_1.default.log((0, chalk_1.default) `{dim - Skipped version and release update, not configured}`);
        }
        else {
            const { versionString } = context.version.attributes;
            const description = [version && 'version', release && 'release']
                .filter(Boolean)
                .join(' and ');
            context.version = await (0, log_2.logAsync)(() => context.version.updateAsync({ ...version, ...release }), {
                pending: `Updating ${description} info for ${chalk_1.default.bold(versionString)}...`,
                success: `Updated ${description} info for ${chalk_1.default.bold(versionString)}...`,
                failure: `Failed updating ${description} info for ${chalk_1.default.bold(versionString)}...`,
            });
        }
        const locales = config.getLocales();
        if (locales.length <= 0) {
            log_1.default.log((0, chalk_1.default) `{dim - Skipped localized version update, no locales configured}`);
        }
        else {
            for (const locale of locales) {
                const attributes = config.getVersionLocale(locale, context);
                if (!attributes) {
                    continue;
                }
                const oldModel = context.versionLocales.find(model => model.attributes.locale === locale);
                await (0, log_2.logAsync)(async () => {
                    return oldModel
                        ? await oldModel.updateAsync(attributes)
                        : await context.version.createLocalizationAsync({ ...attributes, locale });
                }, {
                    pending: `${oldModel ? 'Updating' : 'Creating'} localized version for ${chalk_1.default.bold(locale)}...`,
                    success: `${oldModel ? 'Updated' : 'Created'} localized version for ${chalk_1.default.bold(locale)}`,
                    failure: `Failed ${oldModel ? 'updating' : 'creating'} localized version for ${chalk_1.default.bold(locale)}`,
                });
            }
            context.versionLocales = await context.version.getLocalizationsAsync();
        }
    }
}
exports.AppVersionTask = AppVersionTask;
/**
 * Resolve the AppStoreVersion instance, either from live or editable version.
 * This also checks if this is the first version, which disallow release notes.
 */
async function resolveVersionAsync(app, { editLive, platform }) {
    let version = null;
    let versionIsLive = false;
    if (editLive) {
        version = await app.getLiveAppStoreVersionAsync({ platform });
        versionIsLive = !!version;
    }
    if (!version) {
        version = await (0, retry_1.retryIfNullAsync)(() => app.getEditAppStoreVersionAsync({ platform }));
    }
    const versions = await app.getAppStoreVersionsAsync({
        query: { limit: 2, filter: { platform } },
    });
    return {
        version,
        versionIsLive,
        versionIsFirst: versions.length === 1,
    };
}
